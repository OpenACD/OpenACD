What's a call?
id: String
type: atom
callerid:  string
source: Media Manager Pid
bound: list of dispater pid's
client:  client record
skills:  list of atoms

delivery recipe:

a delivery recipe ticks every 10 seconds.
One delivery reciple process per call, so that 'ticks' are based on the calls '0 hour' rather than all ticking at once.

[{Ticks, operation, [arguments], run_once | run_many}, 
...]

Ticks:
	On every nth Tick evaluate this.

operations:  an atom of:
	new_queue
	add_skills
	remove_skills
	set_priority
	prioritize
	deprioritize
	voicemail
	announce
	add_recipe
	
arguments: determined by the operation.

run_once | run_many
	run_once means remove this recipe after it has run
	run_many means continue running every nth Tick.
	
dispatcher matching a call to agent:
select from agents with the shortest skill list that contains all the calls required skills ordered by the agent's idle time descending.

(queue_wieight * calls_in_queue) / total_wieght = % time a dispatcher should go to this queue.
Need to find a way to round robin the above, for now biased random.
bias up local calls rather than remote ons.
path_bonus, if local is potentially 10, lower if remoter.

dispatchers are spawned and killed as a ratio of agents avialable (rather than total agents like stated earlier).

each call that comes in will have a required skill named the same as the node it is local too.  Each agent on that node will have the same skill.  A default recipe will remove that skill from the call after a certin amount of time, thus opening the call to non-local agents.

magic skills:  _node translates to the node, and _agent translate to an agent's login.  All skills that start with an underscore are reserved as magic skills.



We can get the most important call,
and we can get matches of agents (list of agents).
algorithm for waiting on sending it over.
on tick:
	ask dispatchers for thier lists (m-m-m-m-multicast!)
	
path costs:
	local :  +0
	remote:  +X (for now, later each node may know it's own uplink cost, chanign this to Node1+node2)
	skills: +skills
	idle: +laststatechange

once a call is ringing to an agent listen:
	to ourselves (queue) in case it's not answered in X amount of time
	to the agent in case they change state (answer or release)
	to the media manager in case the call drops.
	
media manager
	agent_goes_ringing
	caller_hangup
	agent_hangup
	agent_pickup
	agent_outbound
	caller_pickup

originate on asterix from agent to remote

seems we'll need 2 major patterns for handling media:
stateful (calls, chats),
stateless (vm's, emails)

stateful takes it's major changes between agent and media server from the media server.  Media server trickles up, 

split ring configurable:  during negotiation the agentui will tell the agent server 'here's where/what I want to ring', that data is stored on the server.

Out of band propigation for a sip call:
sip phone says to black box 'oncall'
black box says to media manager 'oncall'
media manager says to agentfsm 'oncall'
agentfsm says to agent_conneciton 'oncall'
agent_conneciton says to agent ui 'oncall'

For agent web ui:
agent_web_listener
agent_web_connection

agent_web_listener listens a web connection (using mochiweb at this time).
agent_web_connection has the state and queued events for an agent logged in via web.

When agent_web_listener maintains an ets table of cookie_id : agent_web_connection_pid.
When a request comes in, if the cookie id has a pid associated with it, that agent_web_connection handles it, 
otherwise the agent_web_connection does a 'negotiate'



freecpx.dev 8021
mod_erlang port:  8031
cookie:  ClueCon
node:  freeswitch@freecpx.dev
test number:  2617542

freeswitch (or other call gw) would hold data on how / which call goes to what queue.  Internally, the queues on the freeswitch are just a heap of calls (with hopefully consistant ids).

vars set by freeswitch:
	brand
	type
	ivr selection
	queue the call goes to
	
	
	
	
	
	
Configs:

Media Managers : [
	{
		module, function, [Args]
	},
	...
]

Queues : [
	{
		name,
		wieght,
		skills : [...],
		recipe : [
			{
				on_ticks,
				action,
				params:{
				
				},
				run_once | run_many
			},
			...
		]
	},
	...
]

skills interpolated by module,
un/pw/skills cached by internal system, updated periocically.

Agent Manager (integration module):{
	module, funciton, args
	tcp_port,
	tcp_ip,
	web_port,
	web_port
}

	