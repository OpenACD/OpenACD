What's a call?
id: String
type: atom
callerid:  string
source: Media Manager Pid
bound: list of dispater pid's
client:  client record
skills:  list of atoms

delivery recipe:

a delivery recipe ticks every 10 seconds.
One delivery reciple process per call, so that 'ticks' are based on the calls '0 hour' rather than all ticking at once.

[{Ticks, operation, [arguments], run_once | run_many}, 
...]

Ticks:
	On every nth Tick evaluate this.

operations:  an atom of:
	new_queue
	add_skills
	remove_skills
	set_priority
	prioritize
	deprioritize
	voicemail
	announce
	add_recipe
	
arguments: determined by the operation.

run_once | run_many
	run_once means remove this recipe after it has run
	run_many means continue running every nth Tick.
	
dispatcher matching a call to agent:
select from agents with the shortest skill list that contains all the calls required skills ordered by the agent's idle time descending.

(queue_wieight * calls_in_queue) / total_wieght = % time a dispatcher should go to this queue.
Need to find a way to round robin the above, for now biased random.
bias up local calls rather than remote ons.
path_bonus, if local is potentially 10, lower if remoter.

dispatchers are spawned and killed as a ratio of agents avialable (rather than total agents like stated earlier).

each call that comes in will have a required skill named the same as the node it is local too.  Each agent on that node will have the same skill.  A default recipe will remove that skill from the call after a certin amount of time, thus opening the call to non-local agents.

magic skills:  _node translates to the node, and _agent translate to an agent's login.  All skills that start with an underscore are reserved as magic skills.



We can get the most important call,
and we can get matches of agents (list of agents).
algorithm for waiting on sending it over.
on tick:
	ask dispatchers for thier lists (m-m-m-m-multicast!)
	
path costs:
	local :  +0
	remote:  +X (for now, later each node may know it's own uplink cost, chanign this to Node1+node2)
	skills: +skills
	idle: +laststatechange

once a call is ringing to an agent listen:
	to ourselves (queue) in case it's not answered in X amount of time
	to the agent in case they change state (answer or release)
	to the media manager in case the call drops.
	
media manager
	agent_goes_ringing
	caller_hangup
	agent_hangup
	agent_pickup
	agent_outbound
	caller_pickup

originate on asterix from agent to remote

seems we'll need 2 major patterns for handling media:
stateful (calls, chats),
stateless (vm's, emails)

stateful takes it's major changes between agent and media server from the media server.  Media server trickles up, 

split ring configurable:  during negotiation the agentui will tell the agent server 'here's where/what I want to ring', that data is stored on the server.

Out of band propigation for a sip call:
sip phone says to black box 'oncall'
black box says to media manager 'oncall'
media manager says to agentfsm 'oncall'
agentfsm says to agent_conneciton 'oncall'
agent_conneciton says to agent ui 'oncall'

For agent web ui:
agent_web_listener
agent_web_connection

agent_web_listener listens a web connection (using mochiweb at this time).
agent_web_connection has the state and queued events for an agent logged in via web.

When agent_web_listener maintains an ets table of cookie_id : agent_web_connection_pid.
When a request comes in, if the cookie id has a pid associated with it, that agent_web_connection handles it, 
otherwise the agent_web_connection does a 'negotiate'







case Req:parse_cookie() of 
		[{"cpx_id", Pcookie}] -> 
			case ets:lookup(Table, Pcookie) of
				{Pcookie, Aconn} -> 
					gen_server:cast(Aconn, [Req]);
				_Whatever -> 
					Method = Req:get(method),
					Path = Req:get(path),
					Post = Req:parse_post(),
					Req:ok({"text/hmtl", io_lib:format("<pre>~p</pre>~n", [Post])})
			end;
		Allothers -> 
			
		
		
			Req:respond({200, [{"Set-Cookie", "goober=foobar"}], io_lib:format("<pre>~p~p</pre>", [Req:dump(), Req:parse_cookie()])});

		
		
		
			Req:ok({"text/hmtl", io_lib:format("<pre>~p~n~n~p</pre>", [Allothers, Req:parse_post()])})
	end.







					
					Req:response
									
									
									handle_cast({request, Req}, State) -> 
									% first, pull out the cookie id and see if we have a process for this already.
									case Req:parse_cookie() of
									[{"cpx_id", Pcookie}] -> 
									{_Whatever, Aconn} = ets:lookup(State#state.connections, Pcookie),
									gen_server:call(Aconn, {request, Req});
									_Other -> 
									{ok, NewConn} = gen_server:start(agent_web_connection, [Req], [])
									end;
