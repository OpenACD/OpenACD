<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Module gen_media</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module gen_media</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>Behaviour module for media types.

<p><b>Behaviours:</b> <a href="gen_fsm.html"><tt>gen_fsm</tt></a>.</p>

<h2><a name="description">Description</a></h2><p>Behaviour module for media types.  Gen_media uses gen_fsm as the  
underlying framework for what it does.  It exposes a gen_server-esque  
behavior for it's callback modules, however.  Any time gen_media  
recieves an event it cannot handle wholly intnerally, it will call a  
specific funciton of the callback module.</p>
 
  <p>Replies from handle_call, handle_cast, and handle_info are extended to  
allow for specific events only media would need.</p>
 
 	<p>Callback functions:</p>
 
 	<p>The callback functions follow a general pattern for thier arguments	 
(aside from init).  It is:		 
[Arg1, Arg2, Arg3, ..., ArgN, StateName, Call, InternalState, State]</p>
 
 	<p>Arg1 ... ArgN are arbitrary terms defined in the documenation for	 
each callback.</p>
 
 	<p>StateName is the current state of the gen_media fsm.  The states most	 
commonly used are inivr, inqueue, inqueue_ringing, oncall,	 
oncall_ringing, and wrapup.</p>
 
 	<p>Call is the most recently #call{}.</p>
 
 	<p>InternalState is the internal state record of the gen_media fsm with	 
the most pertinant data.  These are defined in gen_media.hrl.</p>
 
 	<p>State is the state the callback module last returned from a callback	 
function.  It is used for implementation specific data for medias.</p>
 
 	<p><b>init(Args) -&gt; {ok, {State, Route_hint}}</b>		 
types:  Args = any()				 
State = any()				 
Route_hint = {Queue, #call{}} | undefined | #call{}					 
Queue = string()</p>
 
 		<p>When gen_media starts, this function is called.  It should		 
initialize all required data.</p>
 
 		<p>Some media may not be able to provide a call record on start-up,		 
thus allowing the media to finish prepping and then queue later.</p>
 
 	<p><b>urlpop_getvars(State) -&gt; UrlOptions</b>		 
types:	State = any()				 
UrlOptions = [{string(), string()}]</p>
 
 		<p>When a call rings to an agent, if a pop url is configured, get		 
variables are appended to the end.  If this is set,		 
get_url_getvars/1 will call it and merge the results to what will		 
be used when ringing an agent.  Options set via set_url_getvars/2		 
super-ceede those returned by the callback module.</p>
 
 		<p>At the time of this doc, the agent web interface prompts the agent		 
to adjust the url pop options when doing a queue transfer.</p>
 
 	<p><b>prepare_endpoint(Agent, Data) -&gt; Result</b>		 
types:	Agent = #agent{}				 
Data = 'inband' | any()				 
Result = {ok, NewData} | {error, Error}					 
NewData = any()					 
Error = any()</p>
 
 		<p>When an agent is given a new endpoint for the callback module, this		 
function is called.  If the callback module returns {error, Error}		  
The agent does not store the given endpoint data.  If {ok, NewData}		  
is returned, NewData is stored for the endpoint.</p>
 
 		<p>The atom 'inband' indicates an agent will go ringing despite the		 
presense or absence of a ring pid.  If this behavior is not desired,		 
Module:prepare_endpoint/2 should return {error, any()}, preserving		 
any settings in place already.  If there were no settings, the		 
endpoint is no longer used, and any media requiring it will fail		 
to ring to the agent.</p>
 
 	<p><b>handle_ring(RingData, Agent, Call, State) -&gt; Result</b>		 
types:	RingData = any()				 
Agent = pid()				 
Call = #call{}				 
State = any()				 
Result = {ok, NewState} | {ok, UrlOptions, NewState} |					 
{invalid, NewState}					 
UrlOptions = [{string(), string()}]					 
NewState = any()</p>
 
 		<p>When a call must ring to an agent (either due to out of queue or		 
the start of a transfer), this is called.</p>
 
 		<p>RingData is the data the ring channel returned when confirming it is		 
able to function.  Gen media does not alter or cache it.</p>
 
 		<p>Agent is the pid of the agent that will be set to ringing if		 
Result is {ok, NewState} or {ok, UrlOptions, NewState}.</p>
 
 		<p>Call is the #call{} maintained by the gen_media and passed in for		 
Reference.</p>
 		
 		<p>State is the internal state of the gen_media callbacks.</p>
 
 		<p>If Result is {ok, NewState} or {ok, UrlOptions, NewState}, Agent		 
is set to ringing, and execution continues with NewState.  A		 
url_pop is sent to the agent is the client for the media is set to		 
have one.  In the case of {ok, UrlOptions, NewState}, the		 
UrlOptions are appened to the url as a query (get) string.</p>
 
 		<p>Note that UrlOptions can be set by the agent before a queue		 
transfer occurs.  In this case, before the transfer is made,		 
urlpop_getvars/1 should be used to present the agent with a chance		 
to adjust the url pop.</p>
 
 		<p>If Result is {invalid, NewState}, Agent is set to idle, and		 
execution continues with NewState.</p>
 
 	<p><b>handle_ring_stop(StateName, Call, Internal, State) -&gt; Result</b>		 
types:	StateName = state_name()				 
Call = #call{}				 
Internal = internal_state()				 
State = any()				 
Result = {ok, NewState}					 
NewState = any()</p>
 
 		<p>When an agent should no longer be ringing, such as due to ringout,		 
this function is called.</p>
 
 		<p>State is the internal state of the gen_media callbacks.</p>
 
 		<p>Execution will continue with NewState.</p>
 
 	<p><b>handle_answer({Agent, Apid}, StateName, Call, Internal, State) -&gt;
 		Result</b>		 
types:	Agent = string()				 
Apid = pid()				 
StateName = state_name()				 
Call = #call{}				 
Internal = internal_state()				 
State = any()				 
Result = {ok, NewState} | {error, Error, NewState}					 
Error = NewState = any()</p>
 
 		<p>When an agent should be placed on call after ringing, this function		 
is called.</p>
 
 		<p>Agent is the agent that will be set oncall if Result is		 
{ok, NewState}.</p>
 
 		<p>Call is the #call{} the agent will be answering.</p>
 
 		<p>State is the internal state of the gen_media callbacks.</p>
 
 		<p>If Result is {ok, NewState} and the callpath is inband, it is		 
assumed the agent has already set themselves oncall.  If it is out		 
of band, the agent is set to oncall.  The callback module can		 
always safely assume the agent is oncall.  Execution then		 
continues with NewState.</p>
 
 		<p>If Result is {error, Error, NewState}, the agent's state is not		 
changed and execution continues with NewState.</p>
 
 	<p><b>handle_voicemail(StateName, Call, Internal, State) -&gt; Result</b>		 
types:	StateName = state_name()				 
Call = #call{}				 
Internal = internal_state()				 
State = any()				 
Result = {ok, NewState} | {invalid, NewState}</p>
 
 		<p>This is an optional callback.</p>
 
 		<p>When a media should be removed from queue and moved to voicemail,		 
this is called.</p>
 
 		<p>State is the internal state of the gen_media callbacks.</p>
 
 		<p>If Result is {ok, NewState}, the call is removed from queue and		 
execution continues with NewState.</p>
 
 		<p>If Result is {invalid, NewState} execution continues with NewState.</p>
 
 	<p><b>handle_annouce(Announce, StateName, Call, Internal, State) -&gt;
 		{ok, NewState}</b>		 
types:	Announce = any()				 
StateName = state_name()				 
Call = any()				 
Internal = internal_state()				 
State = NewState = any()</p>
 
 		<p>This is an optional callback.</p>
 
 		<p>When a recipe calls for a call in queue to play an announcement, if		 
this function is defined, it is called.  Execution then continues		 
with NewState.</p>
 
 	<p><b>handle_agent_transfer(Agent, Timeout, StateName, Call, Internal,
 		State) -&gt; Result</b>		 
types:	Agent = pid()				 
Timeout = pos_integer()				 
StateName = state_name()				 
Call = #call{}				 
Internal = internal_state()				 
State = any()				 
Result = {ok, NewState} | {error, Error, NewState}					 
NewState = State = any()					 
Error = any()</p>
 
 		<p>When a media should be transfered to another agent, this is the		 
first step.  The target agent is set to prering, then this		 
callback is used to verify that.  If the callback returns		 
{ok, NewState}, execution continues with NewState, and gen_media		 
handles with oncall or a ringout.</p>
 
 		<p>In the case of an outband ring, that process will send a takeover		 
message to gen_media.</p>
 
 	<p><b>handle_queue_transfer({Queue, Qpid}, StateName, Call, Internal,
 		State) -&gt; {ok, NewState}</b>		 
types:	Queue = string()				 
Qpid = pid				 
StateName = state_name()				 
Call = #call{}				 
Internal = internal_state()				 
State = NewState = any()</p>
 
 		<p>When a media is placed back into queue from an agent, this is		 
called to allow the media to do any required clean up or		 
unbridging.  The Call is requeued at the priority it was initially		 
queued at.  Execution then continues with NewState.</p>
 
 		<p>Queue is the name of the queue the media will be placed in; Qpid is		 
the pid of said queue.</p>
 
 	<p><b>handle_wrapup(From, StateName, Call, Internal, State) -&gt; {Finality,
 		NewState}</b>		 
types:	From = {pid(), reference()}				 
StateName = state_name()				 
Call = #call{}				 
Internal = internal_state()				 
State = NewState = any()				 
Finality = ok | hangup</p>
 
 		<p>This callback is only used if the call record's media path is inband.		 
When an agent goes to wrapup, this gives the callback a chance to		 
do any clean-up needed.</p>
 
 		<p>If the media determines this is a hang-up (ie, no more		 
can be done with the media), it can return {hangup, NewState}.  The		 
gen_media then terminates with state NewState.</p>
 
 		<p>If {ok, NewState} is returned, execution continues with state		 
NewState.</p>
 
 	<p><b>handle_spy(Spy, StateName, Call, Internal, State) -&gt; {ok, NewState}
 		| {invalid, NewState} | {error, Error, NewState}</b>		 
types:  Spy = {Spypid, AgentRec}				 
Spypid = pid() | any()				 
AgentRec = 'undefined' | #agent{}				 
StateName = state_name()				 
Call = #call{}				 
Internal = internal_state()				 
State = NewState = any()</p>
 
 		<p>This callback is optional.</p>
 
 		<p>Spy can be a pid of an agent acting as a spy, or a generic term to		 
be used by the media to allow spying.  When spy is an active, agent,		 
They must be released.</p>
 
 		<p>This signals the callback that a supervisor is attempting to observe		 
the agent that is oncall.  The other callbacks should take into		 
account the possibility of a spy if 'ok' is returned.</p>
 		
 		<p>Be aware that when calling this, gen_media does not have a		 
reliable method to determine an agent's security level.  The agent		 
connections, however, do.</p>
 
 	<p><b>Extended gen_server Callbacks</b></p>
 
 	<p>In addition to the usual replies gen_server expects from it's callback	 
of handle_call/3, handle_cast/2, and handle_info/2, gen_media will	 
take some action based on the following Returns.</p>
 
 	<p>{queue, Queue, Callrec, NewState}		 
types:  Queue = string()				 
Callrec = #call{}				 
NewState = any()</p>
 
 		<p>This result is only valid if the callbacks init/1 returned		 
undefined for the call record.  This sets the call record and		 
queues the call.  Execution then continues on with NewState.  If		 
this is replied to a call, ok is set as the reply.</p>
 
 	<p>{outbound, Agent, NewState}	 
{outbound, Agent, Call, NewState}		 
types:  Agent = pid()				 
Call = #call{}				 
NewState = any()</p>
 
 		<p>This result is valid only if the call is not queued.  The second		 
form is only valid if init/1 retuned an undefined call.  This also		 
assumes the agent at pid() is already in precall state.  If The		 
agent can be set to outgoing, it will be.  Execution continues on		 
with NewState.</p>
 
 	<p>{voicemail, NewState}		 
types:	NewState = any()</p>
 
 		<p>This result is valid only if the call is queued.  Removes the media		 
from queue and stops ringing to an agent it is.  Assumes the media		 
has already	done what it needs to for a voicemail.  If done in a		 
handle_call, the reply is 'ok'.</p>
 
 	<p>{Agentaction, NewState}	 
{Agentaction, Reply, NewState}		 
types:	Agentaction = stop_ring | {stop_ring, Data} | wrapup | hangup |					 
{hangup, Data} | {mediapush, Data, Mode}				 
Reply = any()				 
NewState = any()				 
Data = any()				 
Mode = replace | append</p>
 
 		<p>This result is only valid if an agent has been associated with this		 
media by ringing.  The second form is only valid if the request		 
came in	as a gen_media:call.  This attempts to take the specified		 
action on the agent, then continues execution with NewState.</p>
 
 		<p>{stop_ring, Data} is used to stop the gen_media from handling a
 		ringout.  It does not change the agent's state.  Execution will
 		continue with NewState.  This is useful if there is an error
 		ringing to an agent that only becomes apparent at a later time.  A
 		return of <code>stop_ring</code> is Equivalent to {stop_ring, undefined}.</p>
 
 		<p>wrapup is only valid if there is an agent associated with a media,		 
and	that agent is oncall or outgoing.  This sets the agent to		 
wrapup and continues execution with NewState.</p>
 
 		<p>{hangup, Data} is valid at any time.  This will unqueue the media,		 
and set the appropriate state for any agents.  The cdr record will		 
record Data as who hung up the call.  A return of hangup is		 
equivalent to {hangup, undefined}.  Execution then coninues with		 
NewState.</p>
 
 		<p>mediapush is only valid if there is an agent oncall with the media,		 
and the media is inband.  The given Data is casted to the		 
associaed agent as a media push.</p>
 
 	<p>{stop, hangup, NewState}	 
{stop, {hangup, Data}, NewState}		 
types:  NewState = any()				 
Data = any()</p>
 
 		This causes the media to take any action it would from an
 		Agentaction return tuple of hangup, then stop.
<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#add_skills-2">add_skills/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#agent_transfer-3">agent_transfer/3</a></td><td>Transfer the call from the agent it is associated with to a new agent.</td></tr>
<tr><td valign="top"><a href="#announce-2">announce/2</a></td><td>Pass <code>any() Annouce</code> message to <code>pid() Genmedia</code>.</td></tr>
<tr><td valign="top"><a href="#behaviour_info-1">behaviour_info/1</a></td><td></td></tr>
<tr><td valign="top"><a href="#call-2">call/2</a></td><td>Do the equivalent of a <code>gen_server:call/2</code>.</td></tr>
<tr><td valign="top"><a href="#call-3">call/3</a></td><td>Do the equivalent of <code>gen_server:call/3</code>.</td></tr>
<tr><td valign="top"><a href="#cast-2">cast/2</a></td><td>Do the equivalent of <code>gen_server:cast/2</code>.</td></tr>
<tr><td valign="top"><a href="#end_call-1">end_call/1</a></td><td>End the Call for <code>pid() Genmedia</code>.</td></tr>
<tr><td valign="top"><a href="#get_call-1">get_call/1</a></td><td>Get the call record associated with <code>pid() Genmedia</code>.</td></tr>
<tr><td valign="top"><a href="#get_url_getvars-1">get_url_getvars/1</a></td><td></td></tr>
<tr><td valign="top"><a href="#handle_event-3">handle_event/3</a></td><td></td></tr>
<tr><td valign="top"><a href="#handle_info-3">handle_info/3</a></td><td></td></tr>
<tr><td valign="top"><a href="#handle_sync_event-4">handle_sync_event/4</a></td><td></td></tr>
<tr><td valign="top"><a href="#inivr-2">inivr/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#inivr-3">inivr/3</a></td><td></td></tr>
<tr><td valign="top"><a href="#inqueue-2">inqueue/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#inqueue-3">inqueue/3</a></td><td></td></tr>
<tr><td valign="top"><a href="#inqueue_ringing-2">inqueue_ringing/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#inqueue_ringing-3">inqueue_ringing/3</a></td><td></td></tr>
<tr><td valign="top"><a href="#oncall-1">oncall/1</a></td><td>Set the agent associated with <code>pid() Genmedia</code> to oncall.</td></tr>
<tr><td valign="top"><a href="#oncall-2">oncall/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#oncall-3">oncall/3</a></td><td></td></tr>
<tr><td valign="top"><a href="#oncall_ringing-2">oncall_ringing/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#oncall_ringing-3">oncall_ringing/3</a></td><td></td></tr>
<tr><td valign="top"><a href="#queue-2">queue/2</a></td><td>Transfer the passed media into the given queue.</td></tr>
<tr><td valign="top"><a href="#ring-4">ring/4</a></td><td>Make the <code>pid() Genmedia</code> ring to <code>pid() Agent</code> based off of
  <code>#queued_call{} Qcall</code> with a ringout of <code>pos_integer() Timeout</code> miliseconds.</td></tr>
<tr><td valign="top"><a href="#set_cook-2">set_cook/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#set_queue-2">set_queue/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#set_url_getvars-2">set_url_getvars/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#spy-3">spy/3</a></td><td>Attempt to spy on the agent oncall with the given media.</td></tr>
<tr><td valign="top"><a href="#start-2">start/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#start_link-2">start_link/2</a></td><td>Start a gen_media linked to the calling process.</td></tr>
<tr><td valign="top"><a href="#stop_ringing-1">stop_ringing/1</a></td><td>Send a stop ringing message to <code>pid() Genmedia</code>.</td></tr>
<tr><td valign="top"><a href="#takeover_ring-2">takeover_ring/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#terminate-3">terminate/3</a></td><td></td></tr>
<tr><td valign="top"><a href="#voicemail-1">voicemail/1</a></td><td>Send the passed <code>pid() Genmedia</code> to voicemail.</td></tr>
<tr><td valign="top"><a href="#wrapup-1">wrapup/1</a></td><td>Sends the oncall agent associated with the call to wrapup; or, if it's
  the oncall agent making the request, gives the callback module a chance to
  handle it.</td></tr>
<tr><td valign="top"><a href="#wrapup-2">wrapup/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#wrapup-3">wrapup/3</a></td><td></td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="add_skills-2">add_skills/2</a></h3>
<div class="spec">
<p><tt>add_skills(Genmedia::pid(), Skills::[atom() | {atom(), any()}]) -&gt; ok</tt><br></p>
</div>

<h3 class="function"><a name="agent_transfer-3">agent_transfer/3</a></h3>
<div class="spec">
<p><tt>agent_transfer(Genmedia::pid(), Apid::pid() | string() | {string(), pid()}, Timeout::pos_integer()) -&gt; ok | invalid</tt><br></p>
</div><p>Transfer the call from the agent it is associated with to a new agent.</p>

<h3 class="function"><a name="announce-2">announce/2</a></h3>
<div class="spec">
<p><tt>announce(Genmedia::pid(), Annouce::any()) -&gt; ok</tt><br></p>
</div><p>Pass <code>any() Annouce</code> message to <code>pid() Genmedia</code>.</p>

<h3 class="function"><a name="behaviour_info-1">behaviour_info/1</a></h3>
<div class="spec">
<p><tt>behaviour_info(Info::callbacks | any()) -&gt; [{atom(), non_neg_integer()}] | undefined</tt><br></p>
</div>

<h3 class="function"><a name="call-2">call/2</a></h3>
<div class="spec">
<p><tt>call(Genmedia::pid(), Request::any()) -&gt; any()</tt><br></p>
</div><p>Do the equivalent of a <code>gen_server:call/2</code>.</p>

<h3 class="function"><a name="call-3">call/3</a></h3>
<div class="spec">
<p><tt>call(Genmedia::pid(), Request::any(), Timeout::pos_integer()) -&gt; any()</tt><br></p>
</div><p>Do the equivalent of <code>gen_server:call/3</code>.</p>

<h3 class="function"><a name="cast-2">cast/2</a></h3>
<div class="spec">
<p><tt>cast(Genmedia::pid(), Request::any()) -&gt; ok</tt><br></p>
</div><p>Do the equivalent of <code>gen_server:cast/2</code>.</p>

<h3 class="function"><a name="end_call-1">end_call/1</a></h3>
<div class="spec">
<p><tt>end_call(Genmedia::pid()) -&gt; ok</tt><br></p>
</div><p>End the Call for <code>pid() Genmedia</code>.</p>

<h3 class="function"><a name="get_call-1">get_call/1</a></h3>
<div class="spec">
<p><tt>get_call(Genmedia::pid()) -&gt; #call{}</tt><br></p>
</div><p>Get the call record associated with <code>pid() Genmedia</code>.</p>

<h3 class="function"><a name="get_url_getvars-1">get_url_getvars/1</a></h3>
<div class="spec">
<p><tt>get_url_getvars(Genmedia::pid()) -&gt; {ok, [{string(), string()}]}</tt><br></p>
</div>

<h3 class="function"><a name="handle_event-3">handle_event/3</a></h3>
<div class="spec">
<p><tt>handle_event(Msg, StateName, State) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="handle_info-3">handle_info/3</a></h3>
<div class="spec">
<p><tt>handle_info(Msg, StateName, State) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="handle_sync_event-4">handle_sync_event/4</a></h3>
<div class="spec">
<p><tt>handle_sync_event(Msg, From, StateName, State) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="inivr-2">inivr/2</a></h3>
<div class="spec">
<p><tt>inivr(Msg, State) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="inivr-3">inivr/3</a></h3>
<div class="spec">
<p><tt>inivr(Msg, From, State) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="inqueue-2">inqueue/2</a></h3>
<div class="spec">
<p><tt>inqueue(Msg, State) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="inqueue-3">inqueue/3</a></h3>
<div class="spec">
<p><tt>inqueue(Msg, From, State) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="inqueue_ringing-2">inqueue_ringing/2</a></h3>
<div class="spec">
<p><tt>inqueue_ringing(Msg, State) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="inqueue_ringing-3">inqueue_ringing/3</a></h3>
<div class="spec">
<p><tt>inqueue_ringing(Req, From, State) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="oncall-1">oncall/1</a></h3>
<div class="spec">
<p><tt>oncall(Genmedia::pid()) -&gt; ok | invalid</tt><br></p>
</div><p>Set the agent associated with <code>pid() Genmedia</code> to oncall.</p>

<h3 class="function"><a name="oncall-2">oncall/2</a></h3>
<div class="spec">
<p><tt>oncall(Msg, State) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="oncall-3">oncall/3</a></h3>
<div class="spec">
<p><tt>oncall(Request, From, State) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="oncall_ringing-2">oncall_ringing/2</a></h3>
<div class="spec">
<p><tt>oncall_ringing(Msg, State) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="oncall_ringing-3">oncall_ringing/3</a></h3>
<div class="spec">
<p><tt>oncall_ringing(Msg, From, State) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="queue-2">queue/2</a></h3>
<div class="spec">
<p><tt>queue(Genmedia::pid(), Queue::string()) -&gt; ok | invalid</tt><br></p>
</div><p>Transfer the passed media into the given queue.</p>

<h3 class="function"><a name="ring-4">ring/4</a></h3>
<div class="spec">
<p><tt>ring(Genmedia::pid(), Agent::pid() | string() | {string(), pid()}, Qcall::#queued_call{}, Timeout::pos_integer()) -&gt; ok | invalid | deferred</tt><br></p>
</div><p>Make the <code>pid() Genmedia</code> ring to <code>pid() Agent</code> based off of
  <code>#queued_call{} Qcall</code> with a ringout of <code>pos_integer() Timeout</code> miliseconds.</p>

<h3 class="function"><a name="set_cook-2">set_cook/2</a></h3>
<div class="spec">
<p><tt>set_cook(Genmedia::pid(), CookPid::pid()) -&gt; ok</tt><br></p>
</div>

<h3 class="function"><a name="set_queue-2">set_queue/2</a></h3>
<div class="spec">
<p><tt>set_queue(Genmedia::pid(), Qpid::pid()) -&gt; ok</tt><br></p>
</div>

<h3 class="function"><a name="set_url_getvars-2">set_url_getvars/2</a></h3>
<div class="spec">
<p><tt>set_url_getvars(Genmedia::pid(), Vars::[{string(), string()}]) -&gt; ok</tt><br></p>
</div>

<h3 class="function"><a name="spy-3">spy/3</a></h3>
<div class="spec">
<p><tt>spy(Genmedia::pid(), Spy::pid(), AgentRec::#agent{}) -&gt; ok | invalid | {error, any()}</tt><br></p>
</div><p>Attempt to spy on the agent oncall with the given media.  <code>Spy</code> is
  the pid to send media events/load data to, and <code>AgentRec</code> is an
  <code>#agent{}</code> used to hold the end point data.</p>

<h3 class="function"><a name="start-2">start/2</a></h3>
<div class="spec">
<p><tt>start(Callback::atom(), Args::any()) -&gt; {ok, pid()} | ignore | {error, any()}</tt><br></p>
</div>

<h3 class="function"><a name="start_link-2">start_link/2</a></h3>
<div class="spec">
<p><tt>start_link(Callback::atom(), Args::any()) -&gt; {ok, pid()} | ignore | {error, any()}</tt><br></p>
</div><p>Start a gen_media linked to the calling process.</p>

<h3 class="function"><a name="stop_ringing-1">stop_ringing/1</a></h3>
<div class="spec">
<p><tt>stop_ringing(Genmedia::pid()) -&gt; ok</tt><br></p>
</div><p>Send a stop ringing message to <code>pid() Genmedia</code>.</p>

<h3 class="function"><a name="takeover_ring-2">takeover_ring/2</a></h3>
<div class="spec">
<p><tt>takeover_ring(Genmedia::pid(), Agent::pid() | string() | {string(), pid()}) -&gt; ok | invalid</tt><br></p>
</div>

<h3 class="function"><a name="terminate-3">terminate/3</a></h3>
<div class="spec">
<p><tt>terminate(Reason, StateName, State) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="voicemail-1">voicemail/1</a></h3>
<div class="spec">
<p><tt>voicemail(Genmedia::pid()) -&gt; ok | invalid</tt><br></p>
</div><p>Send the passed <code>pid() Genmedia</code> to voicemail.</p>

<h3 class="function"><a name="wrapup-1">wrapup/1</a></h3>
<div class="spec">
<p><tt>wrapup(Genmedia::pid()) -&gt; ok | invalid</tt><br></p>
</div><p>Sends the oncall agent associated with the call to wrapup; or, if it's
  the oncall agent making the request, gives the callback module a chance to
  handle it.</p>

<h3 class="function"><a name="wrapup-2">wrapup/2</a></h3>
<div class="spec">
<p><tt>wrapup(Msg, State) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="wrapup-3">wrapup/3</a></h3>
<div class="spec">
<p><tt>wrapup(Msg, From, State) -&gt; any()</tt></p>
</div>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, Mar 19 2012, 15:03:22.</i></p>
</body>
</html>
