File generated from /Users/null/erlang/cpx/ebin/../src/call_queue.erl by COVER 2008-10-03 at 14:38:00

****************************************************************************

     0..|  -module(call_queue).
        |  
        |  -ifdef(EUNIT).
        |  -include_lib("eunit/include/eunit.hrl").
        |  -endif.
        |  
        |  -behaviour(gen_server).
        |  -include("call.hrl").
        |  -export([start/1, start_link/1, add/3, ask/1, print/1, remove/2, stop/1, grab/1]).
        |  
        |  %gen_server support
        |  -export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3]).
        |  
        |  start(Name) ->
     4..|  	gen_server:start(?MODULE, [Name], []).
        |  
        |  start_link(Name) ->
     0..|  	gen_server:start_link(?MODULE, [Name], []).
        |  
        |  init([Name]) -> 
     4..|  	put(name, Name),
     4..|  	{ok, gb_trees:empty()}.
        |  
        |  add(Priority, Calldata, Pid) -> 
     6..|  	gen_server:call(Pid, {add, Priority, Calldata}, infinity).
        |  
        |  ask(Pid) -> 
     1..|  	gen_server:call(Pid, ask).
        |  
        |  grab(Pid) -> 
     5..|  	gen_server:call(Pid, grab).
        |  
        |  print(Pid) ->
     0..|  	gen_server:call(Pid, print).
        |  
        |  remove(Calldata, Pid) -> 
     1..|  	gen_server:call(Pid, {remove, Calldata}).
        |  
        |  stop(Pid) ->
     0..|  	gen_server:call(Pid, stop).
        |  
        |  find_unbound(none, _From) -> 
     2..|  	none;
        |  find_unbound({Key, #call{bound = []} = Value, _Iter}, _From) ->
     4..|  	{Key, Value};
        |  find_unbound({Key, #call{bound = B} = Value, Iter}, {From, _}) ->
     6..|  	case lists:filter(fun(Pid) -> node(Pid) =:= node(From) end, B ) of
        |  		[] ->
     0..|  			{Key, Value};
        |  		_ -> 
     6..|  			find_unbound(gb_trees:next(Iter), {From, foo})
        |  	end.
        |  
        |  find_key(Needle, {Key, #call{idnum = Needle}, _Iter}) ->
     1..|  	Key;
        |  find_key(Needle, {_Key, _Value, Iter}) ->
     0..|  	find_key(Needle, gb_trees:next(Iter));
        |  find_key(_Needle, none) -> 
     0..|  	none.
        |  
        |  handle_call({add, Priority, Calldata}, _From, State) -> 
     6..|  	{reply, ok, gb_trees:insert({Priority,now()}, Calldata, State)};
        |  handle_call(ask, From, State) ->
        |  	%generate a call in queue excluding those already bound
        |  	% return a tuple:  {key, val}
     1..|  	{reply, find_unbound(gb_trees:next(gb_trees:iterator(State)), From), State};
        |  handle_call(grab, From, State) ->
        |  	% ask and bind in one handy step
     5..|  	io:format("From:  ~p~n", [From]),
     5..|  	case find_unbound(gb_trees:next(gb_trees:iterator(State)), From) of
        |  		none -> 
     2..|  			{reply, none, State};
        |  		{Key, Value} ->
     3..|  			{Realfrom, _} = From, 
     3..|  			State2 = gb_trees:update(Key, Value#call{bound=lists:append(Value#call.bound, [Realfrom])}, State),
     3..|  			{reply, {Key, Value}, State2}
        |  	end;
        |  
        |  handle_call(print, _From, State) ->
     0..|  	{reply, State, State};
        |  handle_call({remove, #call{} = Calldata}, _From, State) -> 
     1..|  	Key = find_key(Calldata#call.idnum, gb_trees:next(gb_trees:iterator(State))),
        |  	%io:format("Key:  ~p~n", [Key]),
     1..|  	State2 = gb_trees:delete_any(Key, State),
     1..|  	{reply, ok, State2};
        |  handle_call({remove, Id}, _From, State) ->
     0..|  	Key = find_key(Id, gb_trees:next(gb_trees:iterator(State))),
     0..|  	State2 = gb_trees:delete_any(Key, State),
     0..|  	{reply, ok, State2};
        |  handle_call(stop, _From, State) ->
     0..|  	{stop, nicestop, please, State};
        |  handle_call(_Request, _From, State) ->
     0..|  	{reply, ok, State}.
        |  
        |  handle_cast(_Msg, State) ->
     0..|  	{noreply, State}.
        |  
        |  handle_info(_Info, State) -> 
     0..|  	{noreply, State}.
        |  
        |  terminate(_Reason, _State) -> 
     0..|  	ok.
        |  
        |  code_change(_OldVsn, State, _Extra) ->
     0..|  	{ok, State}.
        |  
        |  % begin the defintions of the tests.
        |  
        |  -ifdef(TEST).
        |  
        |  add_test() ->
     1..|  	{_, Pid} = start(goober),
     1..|  	C1 = #call{idnum="C1"},
     1..|  	?assert(add(1, C1, Pid) =:= ok),
     1..|  	?assertMatch({{1, _Time}, C1}, ask(Pid)).
        |  	
        |  remove_test() ->
     1..|  	{_, Pid} = start(goober),
     1..|  	C1 = #call{idnum="C1"},
     1..|  	C2 = #call{idnum="C2"},
     1..|  	add(1, C1, Pid),
     1..|  	add(1, C2, Pid),
     1..|  	remove(C1, Pid),
     1..|  	?assertMatch({_Key, C2}, grab(Pid)).
        |  
        |  grab_test() -> 
     1..|  	C1 = #call{idnum="C1"},
     1..|  	C2 = #call{idnum="C2", bound=[self()]},
     1..|  	C3 = #call{idnum="C3"},
     1..|  	{_, Pid} = start(goober),
     1..|  	add(1, C1, Pid),
     1..|  	add(0, C2, Pid),
     1..|  	add(1, C3, Pid),
     1..|  	?assertMatch({_Key, C1}, grab(Pid)),
     1..|  	?assertMatch({_Key, C3}, grab(Pid)),
     1..|  	?assert(grab(Pid) =:= none).
        |  
        |  grab_empty_test() -> 
     1..|  	{_, Pid} = start(goober),
     1..|  	?assert(grab(Pid) =:= none).
        |  -endif.
