<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Module agent_web_listener</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module agent_web_listener</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>Listens for new web connections, then spawns an
  <a href="agent_web_connection.html"><code>agent_web_connection</code></a> to handle the details.

<p><b>Behaviours:</b> <a href="gen_server.html"><tt>gen_server</tt></a>.</p>
<p><b>See also:</b> <a href="agent_web_connection.html">agent_web_connection</a>, <a href="cpx_web_management.html">cpx_web_management</a>.</p>

<h2><a name="description">Description</a></h2><p>Listens for new web connections, then spawns an
  <a href="agent_web_connection.html"><code>agent_web_connection</code></a> to handle the details.  Uses Mochiweb for  
the heavy lifting.</p>
 
  <h3><a name="Agent_Api">Agent Api</a></h3>
 
  <p>The listener and connection are designed to be able to function with
  any ui that adheres to the api.  The api is broken up between the two
  modules.  agent_web_listener holds the functions that either doe not require a
  speecific agent, or handle the login procedures.  For
  functions dealing with a specific agent, <a href="agent_web_connection.html"><code>agent_web_connection</code></a>.</p>
 
  <p>This module uses <a href="cpx_agent_connection.html"><code>cpx_agent_connection</code></a> for many of it's
  functions.  Login is handled in agent_web_listener and
  <a href="agent_web_connection.html"><code>agent_web_connection</code></a>.  The functions for that system are
  tagged with <b>Agent Api</b>.</p>
 
  <p>Requests from a UI are made over HTTP using POST formatted in  
application/x-www-form-urlencoded (the default on most modern  
browsers) to /api.  The json request object is put into a field labeled  
'request'.</p>
 
  <h3><a name="Hooks">Hooks</a></h3>
 
  Hooks are available when a request is made that an agent connection
  cannot handle.
 
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-cookie_res">cookie_res()</a></h3>
<p><tt>cookie_res() = badcookie | {undefined, undefined, undefined} | {string(), undefined, undefined} | {string(), string(), undefined} | {string(), string(), pid()}</tt></p>


<h3 class="typedecl"><a name="type-web_reply">web_reply()</a></h3>
<p><tt>web_reply() = {non_neg_integer(), [any()], binary()}</tt></p>


<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#check_cookie-1">check_cookie/1</a></td><td><b>Web Api </b> Determine if the cookie the client sent can be associated
  with a logged in agent.</td></tr>
<tr><td valign="top"><a href="#code_change-3">code_change/3</a></td><td></td></tr>
<tr><td valign="top"><a href="#get_brand_list-0">get_brand_list/0</a></td><td><b>Web Api </b> Returns a list of clients confured in the system.</td></tr>
<tr><td valign="top"><a href="#get_queue_list-0">get_queue_list/0</a></td><td><b>Web Api </b> Returns a list of queues configured in the system.</td></tr>
<tr><td valign="top"><a href="#get_release_opts-0">get_release_opts/0</a></td><td><b>Web Api </b> Returns a list of options for use when an agents wants to
  go released.</td></tr>
<tr><td valign="top"><a href="#get_salt-1">get_salt/1</a></td><td><b>Web Api </b> Get the salt and public key information to encrypt the
  password.</td></tr>
<tr><td valign="top"><a href="#handle_call-3">handle_call/3</a></td><td></td></tr>
<tr><td valign="top"><a href="#handle_cast-2">handle_cast/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#handle_info-2">handle_info/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#init-1">init/1</a></td><td></td></tr>
<tr><td valign="top"><a href="#linkto-1">linkto/1</a></td><td>Link to the passed pid; usually an agent pid.</td></tr>
<tr><td valign="top"><a href="#linkto-3">linkto/3</a></td><td>Register an already running web_connection.</td></tr>
<tr><td valign="top"><a href="#login-4">login/4</a></td><td><b>Web Api </b> Login and start an <a href="agent_web_connection.html"><code>agent_web_connection</code></a>.</td></tr>
<tr><td valign="top"><a href="#start-0">start/0</a></td><td>Starts the web listener on the default port of 5050.</td></tr>
<tr><td valign="top"><a href="#start-1">start/1</a></td><td>Starts the web listener on the passed port.</td></tr>
<tr><td valign="top"><a href="#start_link-0">start_link/0</a></td><td>Start linked on the default port of 5050.</td></tr>
<tr><td valign="top"><a href="#start_link-1">start_link/1</a></td><td>Start linked on the given port.</td></tr>
<tr><td valign="top"><a href="#stop-0">stop/0</a></td><td>Stop the web listener.</td></tr>
<tr><td valign="top"><a href="#terminate-2">terminate/2</a></td><td></td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="check_cookie-1">check_cookie/1</a></h3>
<div class="spec">
<p><tt>check_cookie(Cookie::<a href="#type-cookie_res">cookie_res()</a>) -&gt; <a href="#type-web_reply">web_reply()</a></tt><br></p>
</div><p><p><b>Web Api </b> Determine if the cookie the client sent can be associated
  with a logged in agent.  This should be the first step of a login
  process.  If it replies true, then the client can skip the
  <a href="#get_salt-1"><code>get_salt/1</code></a> and <a href="#login-4"><code>login/4</code></a> steps to immediately start a
  poll.  All other times, the client should set the given cookie with all
  subsequent web calls.  The next call after this is usually
  <a href="#get_salt-1"><code>get_salt/1</code></a>.</p>
 
  <p>There are no arguments as anything important happens in the http  
headers.  If the cookie is invalid, the reply will have a set-cookie  
directive in its headers.</p>
 
  The result json is:
  <pre> {
  	"login":     string(),
  	"profile":   string(),
 	"securityLevel":	 "agent" | "supervisor" | "admin",
  	"state":     string(),
  	"statedata": any(),
  	"statetime": timestamp(),
  	"timestamp": timestamp()
   "mediaload": any(); optional
  }</pre></p>

<h3 class="function"><a name="code_change-3">code_change/3</a></h3>
<div class="spec">
<p><tt>code_change(OldVsn, State, Extra) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="get_brand_list-0">get_brand_list/0</a></h3>
<div class="spec">
<p><tt>get_brand_list() -&gt; <a href="#type-web_reply">web_reply()</a></tt><br></p>
</div><p><b>Web Api </b> Returns a list of clients confured in the system.  Useful
  to allow agents to make outbound media.
  Result:
  <code>[{
  	"label":  string(),
  	"id":     string()
  }]</code></p>

<h3 class="function"><a name="get_queue_list-0">get_queue_list/0</a></h3>
<div class="spec">
<p><tt>get_queue_list() -&gt; <a href="#type-web_reply">web_reply()</a></tt><br></p>
</div><p><b>Web Api </b> Returns a list of queues configured in the system.  Useful
  if you want agents to be able to place media into a queue.
  Result:
  <code>[{
  	"name": string()
  }]</code></p>

<h3 class="function"><a name="get_release_opts-0">get_release_opts/0</a></h3>
<div class="spec">
<p><tt>get_release_opts() -&gt; <a href="#type-web_reply">web_reply()</a></tt><br></p>
</div><p><b>Web Api </b> Returns a list of options for use when an agents wants to
  go released.
  Result:
  <code>[{
  	"label":  string(),
  	"id":     string(),
  	"bias":   -1 | 0 | 1
  }]</code></p>

<h3 class="function"><a name="get_salt-1">get_salt/1</a></h3>
<div class="spec">
<p><tt>get_salt(Cookie::<a href="#type-cookie_res">cookie_res()</a>) -&gt; <a href="#type-web_reply">web_reply()</a></tt><br></p>
</div><p><p><b>Web Api </b> Get the salt and public key information to encrypt the
  password.  Should be the second step in logging in.  Remember the client
  must be able to send the same cookie it got in the check cookie step.
  If the cookie does not pass inspection, a salt and public key info will
  still be sent, but there will be a new cookie header sent as well.  This
  means this function does not allow for state recovery like
  <a href="#check_cookie-1"><code>check_cookie/1</code></a> does.</p>
 
  <p>After getting a successful response from this web api call, move on to
  <a href="#login-4"><code>login/4</code></a>.</p>
 
  <p>There are no arguments for this request.</p>
 
  A result is:
  <pre> {
  	"salt":   string(),
  	"pubkey": {
  		"E":   string(),
  		"N":   string()
  	}
  }</pre></p>

<h3 class="function"><a name="handle_call-3">handle_call/3</a></h3>
<div class="spec">
<p><tt>handle_call(Request, From, State) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="handle_cast-2">handle_cast/2</a></h3>
<div class="spec">
<p><tt>handle_cast(Msg, State) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="handle_info-2">handle_info/2</a></h3>
<div class="spec">
<p><tt>handle_info(Info, State) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="init-1">init/1</a></h3>
<div class="spec">
<p><tt>init(Options) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="linkto-1">linkto/1</a></h3>
<div class="spec">
<p><tt>linkto(Pid::pid()) -&gt; ok</tt><br></p>
</div><p>Link to the passed pid; usually an agent pid.</p>

<h3 class="function"><a name="linkto-3">linkto/3</a></h3>
<div class="spec">
<p><tt>linkto(Ref::reference(), Salt::any(), Pid::pid()) -&gt; ok</tt><br></p>
</div><p>Register an already running web_connection.</p>

<h3 class="function"><a name="login-4">login/4</a></h3>
<div class="spec">
<p><tt>login(Cookie::<a href="#type-cookie_res">cookie_res()</a>, Username::string(), Password::string(), Opts::[any()]) -&gt; <a href="#type-web_reply">web_reply()</a></tt><br></p>
</div><p><p><b>Web Api </b> Login and start an <a href="agent_web_connection.html"><code>agent_web_connection</code></a>.  This is
  the second to last step in logging in a web client (the final one
  starting a poll).  Using the salt and public key information recieved in
  <a href="#get_salt-1"><code>get_salt/1</code></a>, encrypt the password.  Using the built-in gui as an
  example, the password is encrypted by via the javascript library jsbn:
  <code>var getSaltPubKey = 	getSaltResult.pubkey;
  var rsa = new RSAKey();
  rsa.setPublic(getSaltPubKey.N, getSaltPubKey.E);
  rsa.encrypt(getSaltResult.salt + password);</code>  
Order of the salt and password is important.</p>
 
  <p>If voipdata is not defined, then it is assumed the agent will register a  
phone via sip using thier login name.</p>
 
  <p>The web api for this actually only takes 3 arguments in the <code>"args"</code>  
property of the request:</p>
 
  <p><code>[username, password, options]</code></p>
 
  <code>username</code> and <code>password</code> are both string().  <code>options</code> is a json
  object:
  <pre> {
  	"voipendpointdata":  string(),
  	"voipendpoint":  "sip_registration" | "sip" | "iax2" | "h323" | "pstn",
  	"useoutbandring":  boolean(); optional,
   "usepersistentring":  boolean(); optional
   "supervisor":boolean(); optional
  }</pre>
 
  <p>If <code>"voipendpoint"</code> is defined but <code>"voipendpointdata"</code> is not,
  <code>"username"</code> is used.</p>
 
  <p>If <code>"supervisor"</code> is <code>true</code>, no agent is logged in and only supervisor
  calls will be available (<a href="supervisor_web_connection.html"><code>supervisor_web_connection</code></a>).  A poll is
  still created.  If the credentials given do not point to an agent with
  <code>supervisor</code> or <code>admin</code> security level, an error is generated.  An  
agent with sufficient security clearance can request supervisor actions  
and polling.</p>
 
  <p>Note an agent starts out in a relased state with reason of default.</p>
 
  A result is:
  <code>{
  	"profile":   string(),
 	"securityLevel":  "agent" | "supervisor" | "admin",
  	"statetime": timestamp(),
  	"timestamp": timestamp()
  }</code></p>

<h3 class="function"><a name="start-0">start/0</a></h3>
<div class="spec">
<p><tt>start() -&gt; {ok, pid()}</tt><br></p>
</div><p>Starts the web listener on the default port of 5050.</p>

<h3 class="function"><a name="start-1">start/1</a></h3>
<div class="spec">
<p><tt>start(Port::non_neg_integer()) -&gt; {ok, pid()}</tt><br></p>
</div><p>Starts the web listener on the passed port.</p>

<h3 class="function"><a name="start_link-0">start_link/0</a></h3>
<div class="spec">
<p><tt>start_link() -&gt; {ok, pid()}</tt><br></p>
</div><p>Start linked on the default port of 5050.</p>

<h3 class="function"><a name="start_link-1">start_link/1</a></h3>
<div class="spec">
<p><tt>start_link(Port::non_neg_integer()) -&gt; {ok, pid()}</tt><br></p>
</div><p>Start linked on the given port.</p>

<h3 class="function"><a name="stop-0">stop/0</a></h3>
<div class="spec">
<p><tt>stop() -&gt; ok</tt><br></p>
</div><p>Stop the web listener.</p>

<h3 class="function"><a name="terminate-2">terminate/2</a></h3>
<div class="spec">
<p><tt>terminate(Reason, State) -&gt; any()</tt></p>
</div>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, Mar 19 2012, 12:52:44.</i></p>
</body>
</html>
