<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Module cpx_monitor</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module cpx_monitor</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>Event dispatcher and limited data mogul.

<p><b>Behaviours:</b> <a href="/Users/micahw/src/OpenACDv2/deps/gen_leader/doc/gen_leader.html"><tt>gen_leader</tt></a>.</p>

<h2><a name="description">Description</a></h2>Event dispatcher and limited data mogul.  Messages sent here are
  forwarded on to the subscribers.  Some events will have it's payload
  cached for easy retreival later.
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-auto_restart_mnesia_opt">auto_restart_mnesia_opt()</a></h3>
<p><tt>auto_restart_mnesia_opt() = auto_restart_mnesia | {auto_restart_mnesia, boolean()}</tt></p>


<h3 class="typedecl"><a name="type-data_key">data_key()</a></h3>
<p><tt>data_key() = {<a href="#type-data_type">data_type()</a>, Name::string() | atom()}</tt></p>


<h3 class="typedecl"><a name="type-data_type">data_type()</a></h3>
<p><tt>data_type() = system | node | queue | agent | media</tt></p>


<h3 class="typedecl"><a name="type-node_opt">node_opt()</a></h3>
<p><tt>node_opt() = {nodes, [atom()] | atom()}</tt></p>


<h3 class="typedecl"><a name="type-option">option()</a></h3>
<p><tt>option() = [<a href="#type-node_opt">node_opt()</a> | <a href="#type-auto_restart_mnesia_opt">auto_restart_mnesia_opt()</a>]</tt></p>


<h3 class="typedecl"><a name="type-options">options()</a></h3>
<p><tt>options() = [<a href="#type-option">option()</a>]</tt></p>


<h3 class="typedecl"><a name="type-proplist">proplist()</a></h3>
<p><tt>proplist() = [<a href="#type-proplist_item">proplist_item()</a>]</tt></p>


<h3 class="typedecl"><a name="type-proplist_item">proplist_item()</a></h3>
<p><tt>proplist_item() = atom() | {any(), any()}</tt></p>


<h3 class="typedecl"><a name="type-time">time()</a></h3>
<p><tt>time() = integer() | {integer(), integer(), integer()}</tt></p>
<p>-type(set_event_payload() :: {data_key(), proplist(), node()}).
-type(drop_event_payload() :: data_key()),
-type(info_event_payload() :: any()}).
-type(event_struct() :: {data_key(), proplist()}).
-type(event_message() ::
	{'set', time(), set_event_payload()} |
	{'drop', time(), data_key()} |
	{'info', time(), info_event_payload()}).
-type(item_monitored() :: 'none' | pid() | atom() | {atom(), atom()}).
-type(monitor_reference() :: reference()).
-type(cached_event() :: {data_key(), proplist(), node(), time(), item_monitored(), monitor_reference()}).</p>

<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#clear_dead_media-0">clear_dead_media/0</a></td><td></td></tr>
<tr><td valign="top"><a href="#drop-1">drop/1</a></td><td>Remove the entry with the key <code>Key</code> from being tracked.</td></tr>
<tr><td valign="top"><a href="#get_key-1">get_key/1</a></td><td>Convience function to get the key from a health tuple.</td></tr>
<tr><td valign="top"><a href="#info-1">info/1</a></td><td>Forward a general message to the subscribers.</td></tr>
<tr><td valign="top"><a href="#set-2">set/2</a></td><td>Creates an entry into the cache using the given key and params.</td></tr>
<tr><td valign="top"><a href="#set-3">set/3</a></td><td>Same as above, but sets up monitoring of the passed pid or node so
  if it dies, a <code>drop</code> event is automcatically generated and sent out for
  the given <code>Key</code>.</td></tr>
<tr><td valign="top"><a href="#start-1">start/1</a></td><td>See <a href="#start_link-1"><code>start_link/1</code></a></td></tr>
<tr><td valign="top"><a href="#start_link-1">start_link/1</a></td><td>Start the monitor using the passed options.<ul>
  <li>nodes :: Nodes to monitor, multiple uses append new values.</li>
  <li>auto_restart_mnesia :: if set to true, this will restart mnesia after
  a merge when recoving from a net-split.  Otherwise mnesia must be started
  manuall.</li>
  </ul></td></tr>
<tr><td valign="top"><a href="#stop-0">stop/0</a></td><td>Stops the monitor.</td></tr>
<tr><td valign="top"><a href="#subscribe-0">subscribe/0</a></td><td>Subscribe the calling process to all events from ?MODULE.</td></tr>
<tr><td valign="top"><a href="#subscribe-1">subscribe/1</a></td><td>Subscribe the calling process to certain events.</td></tr>
<tr><td valign="top"><a href="#unsubscribe-0">unsubscribe/0</a></td><td>Unsubscribe the calling process to events from ?MODULE.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="clear_dead_media-0">clear_dead_media/0</a></h3>
<div class="spec">
<p><tt>clear_dead_media() -&gt; ok</tt><br></p>
</div>

<h3 class="function"><a name="drop-1">drop/1</a></h3>
<div class="spec">
<p><tt>drop(Key::<a href="#type-data_key">data_key()</a>) -&gt; ok</tt><br></p>
</div><p>Remove the entry with the key <code>Key</code> from being tracked.  If
  monitoring was set up, it's halted as well.</p>

<h3 class="function"><a name="get_key-1">get_key/1</a></h3>
<div class="spec">
<p><tt>get_key(Tuple::{<a href="#type-data_key">data_key()</a>, <a href="#type-time">time()</a>, <a href="#type-proplist">proplist()</a>} | {<a href="#type-data_key">data_key()</a>, <a href="#type-time">time()</a>, <a href="#type-proplist">proplist()</a>}) -&gt; <a href="#type-data_key">data_key()</a></tt><br></p>
</div><p>Convience function to get the key from a health tuple.</p>

<h3 class="function"><a name="info-1">info/1</a></h3>
<div class="spec">
<p><tt>info(Params::any()) -&gt; ok</tt><br></p>
</div><p>Forward a general message to the subscribers.  There is no caching
  or monitoring done for this.</p>

<h3 class="function"><a name="set-2">set/2</a></h3>
<div class="spec">
<p><tt>set(Key::<a href="#type-data_key">data_key()</a>, Params::<a href="#type-proplist">proplist()</a>) -&gt; ok</tt><br></p>
</div><p>Creates an entry into the cache using the given key and params.
  Existing entrys are overwritten.  If the params list does not contain an
  entry key of <code>node</code>, <code>{node, node()}</code> is prepended to it.</p>

<h3 class="function"><a name="set-3">set/3</a></h3>
<div class="spec">
<p><tt>set(Key::<a href="#type-data_key">data_key()</a>, Params::<a href="#type-proplist">proplist()</a>, WatchMe::pid() | atom()) -&gt; ok</tt><br></p>
</div><p>Same as above, but sets up monitoring of the passed pid or node so
  if it dies, a <code>drop</code> event is automcatically generated and sent out for
  the given <code>Key</code>.</p>

<h3 class="function"><a name="start-1">start/1</a></h3>
<div class="spec">
<p><tt>start(Args::<a href="#type-options">options()</a>) -&gt; {ok, pid()}</tt><br></p>
</div><p>See <a href="#start_link-1"><code>start_link/1</code></a></p>

<h3 class="function"><a name="start_link-1">start_link/1</a></h3>
<div class="spec">
<p><tt>start_link(Args::<a href="#type-options">options()</a>) -&gt; {ok, pid()}</tt><br></p>
</div><p>Start the monitor using the passed options.<ul>
  <li>nodes :: Nodes to monitor, multiple uses append new values.</li>
  <li>auto_restart_mnesia :: if set to true, this will restart mnesia after
  a merge when recoving from a net-split.  Otherwise mnesia must be started
  manuall.</li>
  </ul></p>

<h3 class="function"><a name="stop-0">stop/0</a></h3>
<div class="spec">
<p><tt>stop() -&gt; any()</tt><br></p>
</div><p>Stops the monitor.</p>

<h3 class="function"><a name="subscribe-0">subscribe/0</a></h3>
<div class="spec">
<p><tt>subscribe() -&gt; ok</tt><br></p>
</div><p>Subscribe the calling process to all events from ?MODULE.</p>
<p><b>See also:</b> <a href="#subscribe-1">subscribe/1</a>.</p>

<h3 class="function"><a name="subscribe-1">subscribe/1</a></h3>
<div class="spec">
<p><tt>subscribe(Fun::function()) -&gt; ok</tt><br></p>
</div><p>Subscribe the calling process to certain events.  If the fun returns
  true, the event is forwarded on, otherwise not.  Subsequent calls to
  this from the same pid over-writes the previous setting.</p>

<h3 class="function"><a name="unsubscribe-0">unsubscribe/0</a></h3>
<div class="spec">
<p><tt>unsubscribe() -&gt; ok</tt><br></p>
</div><p>Unsubscribe the calling process to events from ?MODULE.</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, Mar 19 2012, 15:03:23.</i></p>
</body>
</html>
